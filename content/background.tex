\chapter{Background and Related Work}

This chapter provides a brief overview of the background on SAT and SMT solving, CDCL algorithm, IPASIR and IPASIR-UP interfaces, as well as related work.

\section{Overview of SAT Solvers}

% SAT problem
% SAT solver
The Boolean Satisfiability Problem (SAT) is the problem of determining whether there exists an assignment of truth values to variables such that a given Boolean formula evaluates to true. It is the first problem proven to be NP-complete, making it foundational in computational complexity and automated reasoning. Despite this theoretical hardness, modern SAT solvers have become highly effective in solving many practical instances occurred in the fields such as hardware verification, model checking, and automated theorem proving by using a variety of pre-processing and in-processing techniques and heuristics.

% CNF
In common practice, the Boolean formula is normalized in Conjunctive Normal Form (CNF) as input to the SAT solvers. A CNF formula is a conjunction (AND) of clauses, where each clause is a disjunction (OR) of literals. A literal is either a Boolean variable, indexed by positive integers, or its negation.

% incremental solving
Moreover, in many applications, SAT problems evolve over time. New clauses or variables are added, and assumptions are changed. Restarting the solver from scratch for each update is inefficient. To address this, modern solvers also support incremental solving, allowing themselves to retain learned information and states across multiple calls.

% CDCL
Most SAT solvers employ the Conflict-Driven Clause Learning (CDCL) algorithm to solve SAT problems. It iteratively assigns a chosen literal, does propagation, detects and analyzes conflicts to learn new clauses and backtracks to a previous decision level, or when no conflicts arise, decides on another literal to propagate and continues the loop. It returns UNSAT when a conflict happens at root level, and returns SAT if all variables find an assignment. In this approach, the solving progress are kept in learnt clauses, which also makes it possible for efficiently solving incremental SAT problems.

% IPASIR
The IPASIR interface (reversed acronym for "Re-entrant Incremental Satisfiability Application Program Interface") defines a universal API for incremental SAT solving and is the standard interface for the incremental track of many SAT competitions over the years \cite{BALYO201645}. It allows user to add clauses and new assumptions before each solver call, and to retrieve value of literals from a satisfiable solution or failed assumptions from an unsatisfiable result, which is sufficient for some incremental solving tasks.

% MiniSat
MiniSat is a ``minimalistic, easy to modify and efficient open-source SAT solver'' \cite{10.1007/978-3-540-24605-3_37}. It internally employs CDCL algorithm with 2-watching scheme, and it supports incremental solving with interfaces similar to IPASIR.

% 2-waching scheme, trail and reason clause
The 2-watching scheme makes it highly efficient to perform propagation, in which each clause is watched by two non-falsified literals, and if one watching literal becomes falsified during propagation, another must be found, or it leads to further propagations or a conflict. A \code{trail} is where all the assigned literals of each decision level are kept. And each assigned variable, if it's not from a unit clause or assigned as a decision, stores a reference to its reason clause for conflict analysis to trace back the assignments of literals that contribute to a conflict.

% other SAT solvers
Even though there are currently other SAT solvers, like CaDiCaL \cite{BiereFallerFazekasFleuryFroleyks-CAV24}, that outperforms MiniSat in recent SAT competitions. MiniSat is still an ideal starting point for researching and experimenting new designs for its efficiency and simplicity. It is also integrated as a backend in many other applications, including SMT solver cvc5.

\section{IPASIR-UP Interface}

% background
In order to achieve a more fine-grained interaction between user applications and SAT solvers, IPASIR-UP interface was introduced and developed \cite{fazekas_et_al:LIPIcs.SAT.2023.8}\cite{FazekasNiemetzPreinerKirchwegerSzeiderBiere-JAIR24}. IPASIR-UP interface is an extension of IPASIR interface with user propagators. It allows more control over the solving process from user applications with a set of callback functions, where the solver does it basic job on propagating and in-processing, and user can perform decisions, do external propagations or raise conflict clauses in each CDCL loop. Even though it is not trivial to implement such an interface on a SAT solver, it enables more user applications to cooperate with the SAT solver without many application specific workarounds. A recent version of cvc5 and the SAT Modulo Symmetries (SMS) framework utilize the IPASIR-UP interface for their integrations with CaDiCaL.

% description of functions
The IPASIR-UP interface contains multiple callback functions in the form of virtual functions in \code{C++}, as the code below shows. These interfaces need to be inherited and implemented by the user applications and will be called by the SAT solver in different solving stages. The \code{cb_} prefix stands for \code{callback}.

\begin{lstlisting}
class UserPropagator {
public:
  virtual ~UserPropagator() {};

  virtual void notify_assignment(const std::vector<int>& lits) {}
  virtual void notify_new_decision_level() {}
  virtual void notify_backtrack(size_t new_level) {}

  virtual int cb_decide() { return 0; }
  virtual int cb_propagate() { return 0; }
  virtual int cb_add_reason_clause_lit(int propagated_lit) { return 0; }
  virtual bool cb_check_found_model(const std::vector<int>& model) {
    return true;
  }

  virtual bool cb_has_external_clause(bool& is_forgettable) {
    return false;
  }
  virtual int cb_add_external_clause_lit() { return 0; }
};
\end{lstlisting}

They can be grouped and explained in the following way for a better understanding:

\begin{itemize}
  \item To notify assignments, new decision level and backtracking.
    \begin{itemize}
      \item \code{notify_assignment}: Notifies user propagator a list of newly assigned literals on the current decision level, for the user application to perform external propagation, do model checking or raise possible conflict clauses. Therefore, the notification is not necessarily eager, but should in principle be performed before other callbacks. Only the assignments of observed variables will be notified, and the observed variables can be set or removed.
      \item \code{notify_new_decision_level}: Notifies user propagator a new decision level from the SAT solver, so that user propagator can store the current solving context and return to it when backtracking is performed.
      \item \code{notify_backtrack}: Notifies user propagator that a backtracking to a specific decision level is initiated, for it to unassign variables which are assigned at higher levels and restore to the solving context of this level.
    \end{itemize}
  \item To request external clauses.
    \begin{itemize}
      \item \code{cb_has_external_clause}: Requests user propagator for a possible external clause during solving, after notifying current assignments. If \code{true} is returned, which means there exists a clause to be added, then the next callback function \code{cb_add_external_clause_lit} is called. User application can mark an external clause as \code{forgettable}, allowing the solver to remove it like other learnt clauses when simplifying clause database.
      \item \code{cb_add_external_clause_lit}: Gets the literals of the external clause one by one, terminating with 0.  
    \end{itemize}
  \item To request external propagations and lazily add reason clauses.
    \begin{itemize}
      \item \code{cb_propagate}: Requests user propagator for a possible externally propagated literal, whose reason clause may be later requested by the next callback function \code{cb_add_reason_clause_lit}. User propagator returns 0 if there isn't any. Usually when a literal is assigned, we need to explain the assignment with a reason clause, which will be needed during conflict analysis. But considering that in practice usually not all reason clauses will be examined, so it could be more efficient that the reason is not provided to the solver immediately, but only when it is needed, to avoid unnecessary clause processing and addition space for storing the clause, as well as the cost of generating the reason clause on the user application side.
      \item \code{cb_add_reason_clause_lit}: Gets the literals of the reason clause for an externally propagated literal one by one, terminating with 0. This is usually called while doing conflict analysis and the reason clause is to be lazily added. The clause will be non-forgettable.
    \end{itemize}
  \item To request next decision or a full model check.
    \begin{itemize}
      \item \code{cb_decide}: Requests user propagator for the next decision literal. User propagator might have its own decision heuristics based on its larger context. If 0 is returned, the solver will make the decision by itself as usual.
      \item \code{cb_check_found_model}: Asks user propagator for a full model check when all variables are assigned before solver returns SAT. If user propagator returns false, which means the model is not consistent, solver requests possible external propagations with \code{cb_propagate} and external clauses with \code{cb_has_external_clause} again. The user propagator must provide the conflict through either of the callbacks, and the solving loop will continue. Otherwise, the solving finishes.
    \end{itemize}
\end{itemize}

Several additional configuration functions are also included in the interface which need to be implemented by the solver and are called by the user. They are:

\begin{lstlisting}
  void connect_user_propagator(UserPropagator* user_propagator);
  void disconnect_user_propagator();
  void add_observed_var(int var);
  void remove_observed_var(int var);
  bool is_decision(int observed_var);
  void phase(int lit);
  void unphase(int lit);
\end{lstlisting}

And a short explanation of these functions is as follows:

\begin{itemize}
  \item To connect and disconnect user propagator. The user propagator is an object derived from and implementing \code{UserPropagator}. After connecting, the solver will be able to call the callback functions in the user propagator during solving. Only one user propagator can be connected at a time.
  \begin{itemize}
    \item \code{connect_user_propagator}
    \item \code{disconnect_user_propagator}
  \end{itemize}
  \item To add or remove observed variables. User can add observed variables to the SAT solver whose assignments will be notified. Observed variables shouldn't be eliminated by the solver.
  \begin{itemize}
    \item \code{add_observed_var}
    \item \code{remove_observed_var}
  \end{itemize}
  \item To set and clear the phase of a variable. The phase acts as a guidance to compute the literal after a variable is selected for the next decision.
  \begin{itemize}
    \item \code{phase}
    \item \code{unphase}
  \end{itemize}
  \item To check if a variable is a decision variable.
  \begin{itemize}
    \item \code{is_decision}
  \end{itemize}
\end{itemize}

\section{Overview of SMT Solvers}

% SMT problem
Satisfiability Modulo Theories (SMT) extends the Boolean Satisfiability Problem (SAT) by adding the ability to reason over richer domains, such as integers, real numbers, arrays, bit-vectors, and uninterpreted functions. Instead of asking whether a Boolean formula is satisfiable, SMT asks whether a more general logical formula is satisfiable with respect to a given background theory in these domains.

% SMT solver
SMT solvers are often built on top of SAT solvers, which specialize in solving the Boolean part of the SMT problems, like in z3 \cite{10.1007/978-3-540-78800-3_24}. Modern SMT solvers often rely on incremental SAT solving to interact with SAT solvers to refine a solution by adding more constraints from the knowledge of theory solvers.

% cvc5
As a rival of z3, cvc5 is a state-of-the-art open-source SMT solver that supports a broad range of theories \cite{10.1007/978-3-030-99524-9_24}. It is the successor to \code{cvc4} in the CVC (cooperating validity checker) family, and is designed for both research and industrial applications.

Internally, cvc5 integrates CDCL based SAT engines, including  MiniSat, with a collection of dedicated theory solvers, where the SAT solvers handle the Boolean abstraction of the input formula, and theory solvers verify the consistency of theory-specific constraints. When a theory conflict is detected, the responsible theory solver generates an explanation in the form of a learned clause, which is fed back to the SAT solver to incrementally guide future searching.

%% integration with cadical through ipasirup
The current version of cvc5 contains a highly customized MiniSat solver integrated as it default SAT engine which supports push/pop of assertion levels, production of resolution proofs and other tight interactions with theory, and is therefore hard to replace. Recently, CaDiCaL with IPASIR-UP interface is also implemented in cvc5 and can be selected by option \code{--sat-solver=cadical}. Even though this implementation is still lack of proof integration, it shows potential to be easily adapted to other SAT solvers and promising performance outcomes without many optimizations.
