\chapter{Background and Related Work}

This chapter provides a brief overview of the background on SAT and SMT solving, the CDCL algorithm, the IPASIR and IPASIR-UP interfaces, as well as related work.

\section{Overview of SAT Solvers}

% SAT problem
% SAT solver
The Boolean Satisfiability Problem (SAT) is the problem of determining whether there exists an assignment of truth values to variables such that a given Boolean formula evaluates to true. It is the first problem proven to be NP-complete, making it foundational in computational complexity and automated reasoning. Despite this theoretical hardness, modern SAT solvers have become highly effective in solving many practical instances occurred in the fields such as hardware verification, model checking, and automated theorem proving by using a variety of preprocessing and inprocessing techniques and heuristics.

% CNF
In common practice, the Boolean formula is normalized in Conjunctive Normal Form (CNF) as input to the SAT solvers. A CNF formula is a conjunction (AND) of clauses, where each clause is a disjunction (OR) of literals. A literal is either a Boolean variable, indexed by positive integers, or its negation.

% incremental solving
Moreover, in many applications, SAT problems evolve over time. New clauses or variables are added, and assumptions can change. Restarting the solver from scratch for each update is inefficient. To address this, modern solvers also support incremental solving, allowing them to retain learned information and states across multiple calls.

% CDCL
Most SAT solvers employ the Conflict-Driven Clause Learning (CDCL) algorithm to solve SAT problems. It iteratively assigns a chosen literal, does propagation, detects and analyzes conflicts to learn new clauses and backtracks to a previous decision level, and when no conflicts arise, decides on another literal to propagate and continues the loop. It returns UNSAT when a conflict happens at root level, and returns SAT if all variables find an assignment. In this approach, the solving progress are kept in learnt clauses, which also makes it possible for efficiently solving incremental SAT problems.

% IPASIR
The IPASIR interface (reversed acronym for "Re-entrant Incremental Satisfiability Application Program Interface") defines a universal API for incremental SAT solving and is the standard interface for the incremental track of many SAT competitions over the years. \cite{BALYO201645} It allows user to add clauses and new assumptions before each solver call, and retrieve value of literals from a satisfiable solution or failed assumptions from an unsatisfiable result, which, for most incremental solving tasks, is sufficient.

% MiniSat
MiniSat is a ``minimalistic, easy to modify and efficient open-source SAT solver''. It internally employes CDCL algorithm with 2-watching scheme, and it supports incremental solving with interfaces similar to IPASIR.

% 2-waching scheme, trail and reason clause
The 2-watching scheme makes it highly efficient to perform propagation, in which each clause is watched by two non-falsified literals, and if one watching literal is falsified during propagation, another must be found, or it leads to propagation or conflict. A \code{trail} is where all the assigned literals of each decision level are kept. And each assigned variable, if it's not from a unit clause, stores a reference to its reason clause for conflict analysis to trace back the literals that contribute to a conflict.

% other SAT solvers
Even though there are currently other SAT solvers like CaDiCaL that outperforms MiniSat in recent SAT competitions. MiniSat is still an ideal starting point for researching and experimenting new designs, for its efficiency and simpilicity. It is also integrated as a backend in many other applications, including SMT solvers like cvc5.

\section{IPASIR-UP Interface}

% background
In order to achieve a more fine-grained interaction between SMT solver and SAT solver, the IPASIR-UP interface is introduced \cite{fazekas_et_al:LIPIcs.SAT.2023.8}. The IPASIR-UP interface is an extension of IPASIR interface with user propagator. It allows more control over the solving process from the user with a set of callback functions, where the solver does it basic job on propagating and inprocessing, and the user can decide the next assignment, propagate units or raise conflicts in each CDCL loop. A recent version of cvc5 implements the IPASIR-UP interface for its integration with CaDiCaL.

% description of functions
The IPASIR-UP interface contains multiple callback functions, which are called by the SAT solver in different solving stages. They can be grouped in the following way:

\begin{itemize}
  \item Notify assignments, new decision levels and backtracks
    \begin{itemize}
      \item \code{notify_assignment} Notifies user propagator a list of newly assigned literals on the current decision level, for the user propagator to perform external propagation, check model and raise possible conflict clauses. Only the assignments of observed variables will be notified, and the observed variables can be set or removed.
      \item \code{notify_new_decision_level} Notifies user propagator a new decision level from the SAT solver, so that user propagator can store the current solving context and return back to it when backtracking is performed.
      \item \code{notify_backtrack} Notifies user propagator that a backtrack to a specific decision level is initiated, for it to unassign variables which are assigned at higher levels and restore to the solving context of this level.
    \end{itemize}
  \item Request external clauses
    \begin{itemize}
      \item \code{cb_has_external_clause} Requests user propagator for a possible external clause during solving, after notifying current assignments. If user propagator returns true, which means there exists a clause to be added, then the next callback function \code{cb_add_external_clause_lit} is called.
      \item \code{cb_add_external_clause_lit} Gets the literals of the external clause one by one, terminating with 0.  
    \end{itemize}
  \item Request external propagations and lazily add reason clauses
    \begin{itemize}
      \item \code{cb_propagate} Requests user propagator for a possible externally propagated literal, whose reason clause may be later requested by the next callback function \code{cb_add_reason_clause_lit}. User propagator returns 0 if there isn't any.
      \item \code{cb_add_reason_clause_lit} Gets the literals of the reason clause for an externally propagated literal one by one, terminating with 0. This is usually called while doing conflict analysis and the reason clause is to be lazily added.
    \end{itemize}
  \item Request next decision or a full model check
    \begin{itemize}
      \item \code{cb_decide} Requests user propagator for the next decision literal. User propagator might have its own decision heuristics based on its context.
      \item \code{cb_check_found_model} Asks user propagator for a full model check when all variables are assigned before solver returns SAT. If user propagator returns false, which means the model is not consistent, solver requests possible external propagations with \code{cb_propagate} and external clauses with \code{cb_has_external_clause} again. The user propagator must raise a conflict through either of the callbacks, and the solving loop will continue. Otherwise the solving finishes.
    \end{itemize}
\end{itemize}

\todo{check the function descriptions, referencing the paper and the comments in the code}

\section{Overview of SMT Solvers}

% SMT problem
Satisfiability Modulo Theories (SMT) extends the Boolean Satisfiability Problem (SAT) by adding the ability to reason over richer domains, such as integers, real numbers, arrays, bit-vectors, and uninterpreted functions. Instead of asking whether a Boolean formula is satisfiable, SMT asks whether a more general logical formula is satisfiable with respect to a given background theory.

% SMT solver
SMT solvers are often built on top of SAT solvers, which specialize in solving the Boolean part of the SMT problems. Modern SMT solvers rely on incremental SAT solving such as IPASIR to interact with SAT solvers to refine a solution by adding more constraints.

% cvc5
cvc5 is a state-of-the-art open-source SMT solver that supports a broad range of theories. \cite{10.1007/978-3-030-99524-9_24} It is the successor to \code{cvc4} in the cvc (cooperating validity checker) family, and is designed for both research and industrial applications.

Internally, cvc5 integrates CDCL-based SAT engines, including  MiniSat, with a collection of dedicated theory solvers, where the SAT solvers handle the Boolean abstraction of the input formula, and theory solvers verify the consistency of theory-specific constraints. When a theory conflict is detected, the responsible theory solver generates an explanation in the form of a learned clause, which is fed back to the SAT solver to guide future search.

%% integration with cadical through ipasirup
The current version of cvc5 contains a highly specialized MiniSat solver integrated as it default SAT engine. In addition, interface for CaDiCaL with IPASIR-UP is also implemented in cvc5 and can be selected by option \code {--sat-solver=cadical}.

%% user push/pop and activation literals
To support cvc5 


\section{Correctness of SAT and SMT Solving}

% fuzzing
Fuzzing is an automated testing technique that generates a large number of random input data to uncover bugs, crashes, or unexpected behavior in software. In the context of SAT and SMT solvers, fuzzing plays a critical role in ensuring correctness, robustness, and performance under diverse and potentially adversarial inputs.

% proof formats
Apart from fuzzing, proof generation is 

\section{Related Work}

% proposals

% cvc5 with CaDiCaL
