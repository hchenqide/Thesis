\chapter{Implementation}

This chapter provides a detailed account of the implementation of MiniSatUP (MiniSat with IPASIR-UP) and the extension of cvc5 for integrating with MinisatUP.

\section{Adaptation of MiniSat to IPASIR-UP}

% overview and principle
Adaptation of MiniSat to IPASIR-UP involves several steps. First, the IPASIR-UP interface is added to the header file and interaction with user propagator is inserted in the solving loop. Then, adding a clause provided by user propagator during solving is implemented. Finally, adding an externally propagated literal from user and lazy explaination of the literal is implemented.

MiniSat contains \code{core} solver and \code{simp} solver. In addition to the core CDCL solving loop performed by \code{core} solver, \code{simp} solver performs subsumption and variable elimation. In this work, only the \code{core} solver is modifed. And the modification is made as minimum as possible, without altering the major control flow of the original code, so that the solver's original behaviour could be preserved while cleanly supporting the IPASIR-UP interface, enabling an easier inspection and comparison of the behaviour change introduced by the modification.

\todo{how many lines of code changed}

% adding UserPropagator interface
Firstly, the \code{UserPropagator} class declaration of the IPASIR-UP interface is added in the header file \code{Solver.h}, and the \code{user_propagator} member variable is added to \code{MiniSat::Solver}, which can be set by \code{connect_user_propagator} for the solver to interact with during solving. If \code{user_propagator} is not initialized, then the \code{Solver} behaves just like the original solver.

% interaction within CDCL loop
%% assignment and backtrack notification
If \code{user_propagator} is initialized in \code{Solver}, it will interact with the solver in each CDCL loop after propagation and possible conflict analysis, before the next decision is made. At the beginning of each interaction, the user propagator is synchronized of the current assignments and possible backtracks. An index on the trail up to which the assignments are notified is maintained for this purpose. Then the user propagator is requested of possible external propagations and external clauses.

%% decision and check model
When there are no such upropagationsnits or clauses, or there's no consequent change of control flow after adding them, the user propagator is requested of the next decision literal, if there are still unassigned variables. The new decision is taken and notified to user propagator while going to the next loop of propagation. Or the user propagator is requested to do a full model check before returning SAT if every variable is assigned, so that a new solver call could be avoided if there should still be inconsistence of model on the user side. And when the model check fails, the loop is continued and user propagator is responsible to provide new propagations or clauses to be taken into account.

% external clause addition during solving
%% comparison with clause addition after solving
Secondly, adding a clause during solving is supported. Adding a clause during solving is more challenging than adding a clause after each solving loop. A normal incremental clause addition, as is required in IPASIR interface, only happens when the solving is finished. At this time a variable is either assigned at root-level or unassigned. The clause to be added can be directly simplified by removing false literals. And after simplification of the clause, there are only 4 cases:

\begin{itemize}
  \item The clause is skipped when it contains a true literal or is tautology.
  \item The result is set as UNSAT when the clause is empty.
  \item The unit is propagated when the clause contains only one literal.
  \item The clause is added to the clause set and watched by the first two literals.
\end{itemize}

But during solving, the literals in a clause can be assigned at different decision levels, and after addition of the clause, there might be multiple consequences that leads to different control flow changes in the current solving loop.

%% interface description
Method \code{bool add_clause_solving(vec<Lit>& clause, bool forgettable, CRef& conflict, bool& propagate)} is added in core \code{MiniSat::Solver}, dedicated to support clause addition during solving. This method handles all scenarios that might happen when a new clause is added during solving. These scenarios are:

\begin{itemize}
  \item The clause is skipped.
  \item The result is UNSAT.
  \item The clause is added, with the following possible consequences:
    \begin{itemize}
      \item No propagation or conflict analysis needed.
      \item Propagation needed.
      \item Conflict analysis needed.
    \end{itemize}
\end{itemize}

The input parameters \code {vec<Lit>& clause} and \code{bool forgettable} give the clause and tell whether it is forgettable. A forgettable clause is indicated by the user propagator when it provides a clause, and it can be removed during simplification of the clause set.

The returning \code {bool} indicates whether UNSAT is produced by this clause (returning true when UNSAT, otherwise false). If propagation is needed, the literal to propagate is assigned and added to trail, the output parameter \code{bool& propagate} is set true, and the program goes to the next loop for propagation. And when conflict analysis is needed, \code{CRef& conflict} ist set as the current added clause, and the program goes to \code{analyze}. When no propagation or conflict analysis is needed, none of the output parameters will be set, and the control flow goes further to check model or the next decision.

\todo{graph: original CDCL loop in minisat and changed loop as in project presentation}

%% invariant of 2-watching scheme

In order to make sure the new clause is added without breaking the existing 2-watching scheme, an invariant across decision levels is established as following:

\begin{itemize}
  \item In decision level \code{l > 0}:
  \begin{itemize}
    \item A propagating clause is watched by the propagated literal(assigned true) and another literal(assigned false), both assigned on level l.
    \item A conflict clause is watched by two literals(both false) on level l.
  \end{itemize}
  \item After backtracking to a lower level \code{k < l}:
  \begin{itemize}
    \item The propagating clause or conflict clause at level l is still watched by the same two literals, now both unassigned.
  \end{itemize}
\end{itemize}

%% implementation

The clause to be added is first sorted by its literals and their current levels in the following order, so that when the first two literals become watching literals of the current clause, the clause will be still watched correctly by the two literals after backtracking according to the invariant:

true literals (level low - high) - unassigned literals - false literals (level high - low)

Similar to clause addition after solving, the clause is also simplified by removing root-level false literals. And when the clause contains a root-level true literal, or it is a tautology, it is skipped and the funtion returns without any additional consequence, and the next clause is requested until there's no more external clauses by the user propagator.

When the clause contains only one literal, it is assigned true after backtracking to root level, and propagated. When the clause contains at least two literals, it is added to the clause set, and is watched by the first two literals after sorting. Depending on the assignment status of the 2 watching literals, there can be 6 cases, and their levels when being assigned can introduce more sub-cases. Each case leads to its own outcome:

\begin{itemize}
  \item \code{false, false}: All literals in this clause are falsified so the clause a conflict. We check the levels of the watching literals (respectively a, b):
  \begin{itemize}
    \item \code{a = b}: This clause is a real conflict. We backtrack to level a/b and do conflict analysis.
    \item \code{a > b}: This clause just needs propagation.
  \end{itemize}
  \item \code{unassigned, false}: Propagation.
  \item \code{unassigned, unassigned}: No further action.
  \item \code{true, false}: When level \code{a > b}, backtrack and propagation, otherwise no further action.
  \item \code{true, unassigned}: No further action.
  \item \code{true, true}: No further action.
\end{itemize}

When the clause causes a propagation, we always backtrack to the level of the second literal, and then assign the first literal on this level, so as to make sure the levels of assignment for the two watching literals are always the same.

\todo{nonchro, introduce out-of-order assignments and the bug with cadical}

% external propagation and lazy explaination

In the last step of adapting MiniSat to IPASIR-UP, external propagation and lazy explaination of the externally propagated literal is supported.

Usually when a literal is assigned, we need to provide its reason clause. And the reason clause is needed during conflict analysis. But considering that not all reason clauses will be explored, it could be more efficient that the reason is not provided to the solver immediately, but only when it is needed, to avoid uncessary storage space and cost of generating the reason clause on the user side.

In the case of external propagation, only the propagated literal is required from the user propagator. This literal will be assigned with a tag \code{CRef_External_False} or \code{CRef_External_True} declaring that its reason clause is not present yet. And since the reason clause is attached with the cooresponding variable of the literal only, the tag must also indicate whether the literal is falsified, so it can be computed correctly from the variable.

When the externally propagated literal from user propagator is already assigned true, we skip it. And when it's already assigned false, which means that there is a conflict, we get the reason clause immediately and add the clause by reusing our previous function \code{add_clause_solving}.

Like a clause added during solving, a clause lazily added during conflict analysis is also sorted the same way and watched by the first two literals, and it can also cause propagation to be re-performed on a lower decision level. When the clause is a unit clause, a backtrack to root level is necessary. And when the watching literals of the clause are of different levels, it is also necessary to align their levels and redo the propagation. When such a backtrack is to be performed on addition of an incoming clause, the conflict analysis will be interrupted by an exception, and the analysis context will be cleared.

\section{Extension of cvc5 for integrating MiniSatUP}

% duplicating the interface for cadical in cvc5

After implementing MiniSatUP, we integrated it with cvc5 based on the existing cvc5 integration with CaDiCaL, where the full \code{UserPropagator} is implemented to handle the interaction between cvc5 and the SAT solver via IPASIR-IP.

\todo{graph cvc5 connecting to both cadical/minisatup with internal minisat}

% adding cadical interface for minisatup

Apart from the IPASIR-UP interfaces, the cvc5 integration with CaDiCaL contains other interfaces that are specific to CaDiCaL. These interfaces are also implemented in MiniSatUP so that we don't need to change the existing code.

\todo{explain a bit of cadical interface}
\todo{explain cvc5 user push-pop/fixed notification/}

% linking minisatup in cvc5

cvc5 is built with CMake and its dependencies are added through \code{find_package} command in CMake. We wrapped MiniSatUP in a CMake package for cvc5 to be able to reference and link with it.

options

