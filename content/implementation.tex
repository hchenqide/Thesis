\chapter{Implementation}

This chapter provides a detailed account of the implementation of our MiniSatUP (MiniSat with IPASIR-UP) and the extension of cvc5 for integrating with MiniSatUP.

\section{Adaptation of MiniSat to IPASIR-UP}

% overview and principle
We extended MiniSat with IPASIR-UP interface in several steps. First, we added the IPASIR-UP interface class to the header file and inserted code for interaction with user propagator in the CDCL solving loop. Then, we implemented adding a clause provided by user propagator during solving. Finally, we supported adding an externally propagated literal from user and lazily adding its reason clause.

MiniSat contains \code{core} solver and \code{simp} solver. In addition to the core CDCL solving loop performed by \code{core} solver, \code{simp} solver performs subsumption and variable elimination. In this work, only the \code{core} solver is modified, and the modification is made as minimum as possible, without altering the major control flow of the original code, so that the solver's original behavior could be preserved while cleanly supporting the IPASIR-UP interface, enabling an easier inspection and comparison of the behavior change introduced by the modification. In total, around 400 lines of code are added including comments, and only around 10 lines of original code are changed.

% adding UserPropagator interface
Firstly, the \code{UserPropagator} class declaration of the IPASIR-UP interface is added in the header file \code{Solver.h}, and the \code{user_propagator} member variable is added to \code{MiniSat::Solver}, which can be set by \code{connect_user_propagator} for the solver to interact with during solving.

% interaction within CDCL loop
%% assignment and backtracking notification
If \code{user_propagator} is not initialized, the \code{Solver} behaves just like originally. And if \code{user_propagator} is initialized in \code{Solver}, it will interact with the solver in each CDCL loop after propagation and possible conflict analysis, and before the next decision is made. At the beginning of each interaction, the user propagator is notified of new assignments and possible backtracking. For this purpose, we maintain an index on the trail up to which the assignments are notified. Then the user propagator is requested of possible external propagations and external clauses.

%% decision and check model
When there are no such propagations or clauses, or there's no consequent change of control flow after adding them, the user propagator is requested of the next decision literal. The new decision is taken and notified to user propagator while going to the next loop of propagation. Or, when all variables are assigned, the user propagator is requested to do a full model check before the solver returns SAT, so that a new solver call could be avoided if there should still be inconsistency of model on the user application side. And when the model check fails, the loop is continued and user application is responsible to provide new propagations or clauses in the next callbacks. Though, this is not enforced and will result in an infinite loop, if user application doesn't provide a conflict even though its model checking keeps failing.

% external clause addition during solving
%% comparison with clause addition after solving
Secondly, adding a clause during solving is supported. Adding a clause during solving is more challenging than adding a clause after each solving finishes. In a normal incremental clause addition, as is required in IPASIR interface, a variable is either assigned at root-level or unassigned. The clause to be added can be directly simplified by removing false literals. And after simplification, there are only 4 possible cases:

\begin{itemize}
  \item The clause is skipped when it contains a true literal or is tautology.
  \item The result is set as UNSAT when the clause is empty.
  \item The unit is assigned propagated when the clause contains only one literal.
  \item The clause is added to the clause set and watched by the first two literals.
\end{itemize}

But during solving, the literals in a clause can be assigned at different decision levels, and after addition of the clause, there might be more possible consequences that lead to different control flow changes in the current solving loop.

%% interface description
Method \code{bool add_clause_solving(vec<Lit>& clause, bool forgettable, CRef& conflict, bool& propagate)} is added in core \code{MiniSat::Solver}, dedicated to support clause addition during solving. This method handles all scenarios that might happen when a new clause is added during solving. These scenarios are:

\begin{itemize}
  \item The clause is skipped.
  \item The result is UNSAT.
  \item The clause is added, with the following possible consequences:
    \begin{itemize}
      \item No propagation or conflict analysis needed.
      \item Propagation needed.
      \item Conflict analysis needed.
    \end{itemize}
\end{itemize}

The input parameters \code {vec<Lit>& clause} and \code{bool forgettable} give the clause and tell whether it is forgettable. A forgettable clause is indicated by the user propagator when it is provided, and it will be added to the clause database by MiniSat like a learnt clause, whose activity will be measured, and with a low activity, it can be removed in the next clause set reduction.

The returning \code{bool} indicates whether UNSAT is produced by this clause (returning true when UNSAT, otherwise false). If propagation is needed, the literal to propagate is assigned and added to trail, the output parameter \code{bool& propagate} is set true, and the program goes to the next loop for propagation. And when conflict analysis is needed, \code{CRef& conflict} is set as the current added clause, and the program goes to conflict analysis. When no propagation or conflict analysis is needed, none of the output parameters will be set, and the control flow goes further to the next decision or model checking.

The interaction with user propagator and adding an external clause is inserted into the original CDCL loop, as Figure~\ref{fig:flow} shows, where \code{interact} block handles notifying assignments, retrieving external clauses from user propagator and other callbacks, and \code{add} block adds a single external clause at one time which might cause different changes of control flow.

\begin{figure}[!htbp]
  \centering
  \includesvg[width=\textwidth]{flow.svg}
  \caption{Original CDCL loop in MiniSat and updated CDCL loop}
  \label{fig:flow}
\end{figure}

%% invariant of 2-watching scheme
In order to ensure a new clause is added in compliance with the 2-watching scheme, an invariant across decisions and backtracking is established as following:

\begin{itemize}
  \item In decision level \code{l > 0}:
  \begin{itemize}
    \item A propagating clause is watched by the propagated literal and another literal which are assigned \code{true, false} respectively, both on level \code{l}.
    \item A conflict clause is watched by two literals both assigned false and on level \code{l}.
  \end{itemize}
  \item After backtracking to a lower level \code{k < l}:
  \begin{itemize}
    \item The propagating clause or conflict clause at level \code{l} is still watched by the same two literals, now both unassigned.
  \end{itemize}
\end{itemize}

%% implementation
In accordance with the invariant, the clause to be added is first sorted by its literals and their assignment levels in the following order:

\begin{center}
  true (level low to high), unassigned, false (level high to low)
\end{center}

This ordering of literals when sorting a new clause ensures that when the first two literals become watching literals of the clause, it will still be watched correctly by the same two literals after backtracking. Actually, the order of leading true or unassigned literals doesn't have to be strict, as they will still remain true or unassigned after backtracking without causing new propagations. But assigning watching literals preferably as the true literals with the lowest levels can possibly avoid further looking for a true literal during propagation.

Similar to clause addition after solving, the clause is also simplified by removing root-level false literals. And when the clause contains a root-level true literal, or it is a tautology, it is skipped and the function returns without any additional consequence, and the next clause is requested until there's no more external clauses from the user propagator.

When the clause contains only one unassigned literal after simplification, the literal is assigned true after backtracking to root level, and propagated. When the clause contains at least two literals, it is added to the clause set, and is watched by the first two literals after being sorted. Depending on the assignment status of the 2 watching literals, there can be 6 cases, and their levels when being assigned can introduce more sub-cases. Each case is handled in a specific way:

\begin{itemize}
  \item \code{false, false}: All literals in this clause are falsified so the clause a conflict. We check the levels of the watching literals (respectively a, b):
  \begin{itemize}
    \item \code{a = b}: This clause is a real conflict. We backtrack to level a/b and do conflict analysis on this level. Further backtracking and propagation will still be performed after conflict analysis.
    \item \code{a > b}: This clause is not a real conflict and can be fixed by propagation on level b.
  \end{itemize}
  \item \code{unassigned, false}: Propagation.
  \item \code{unassigned, unassigned}: No further action.
  \item \code{true, false}: When \code{a > b}, propagation, otherwise no further action.
  \item \code{true, unassigned}: No further action.
  \item \code{true, true}: No further action.
\end{itemize}

When the clause causes a propagation, we always backtrack to the level of the second literal, and then assign the first literal on this level, to make sure the levels of assignment for the two watching literals are always the same. Backtracking just to redo an existing assignment on a different level seems inefficient, since all the effort of propagation so far after this level is wasted. To address this problem, it is also possible to just change the level of assignment for a variable without backtracking and losing any existing assignments. This is known as out-of-order assignment or chronological backtracking, but it is tricky and not necessary for our adaptation.

% external propagation and lazy explaination
In the last step of adapting MiniSat to IPASIR-UP, external propagation and lazy explanation of the externally propagated literal is supported. We inserted the callback function \code{cb_propagate} in the interaction code with user propagator to request propagated literals before requesting external clauses. The corresponding variable of the literal will be assigned accordingly with a tag \code{Clause_External} as a placeholder for its reason clause. If the literal is already assigned true, we skip it. And if it's already assigned false, which means that there is a hidden conflict, we get its reason clause immediately and add the clause reusing our previous function \code{add_clause_solving}.

During conflict analysis, reason clauses of assignments will be accessed for searching, and when a variable marked with \code{Clause_External} needs to be explained, we request the clause with callback \code{cb_add_reason_clause_lit} from user propagator. Like a clause being added during solving, a clause lazily added during conflict analysis is also sorted the same way, though in this case it is either a root-level unit clause, or watched by the first two literals, which are always \code{true, false} respectively, because the reason clause at this time should always be true with its only true literal being the literal to be explained.

Adding this true clause during conflict analysis can also cause propagation to be re-performed on a lower decision level, similar to the \code{unit} case and \code{true, false} case when adding an external clause. When the clause is a unit clause, a backtracking to root level is necessary, as long as chronological backtracking is not implemented. And when the watching literals of the clause are of different levels, it is also necessary to backtrack to the lower level and redo propagation to align their levels. Thus, a possible backtracking can break the current conflict analysis. Figure~\ref{fig:analyze} shows an updated CDCL loop for adding a reason clause lazily during conflict analysis which might cause backtracking and propagation.

\begin{figure}[!htbp]
  \centering
  \includesvg[width=0.7\textwidth]{analyze.svg}
  \caption{Updated CDCL loop with clause addition during conflict analysis}
  \label{fig:analyze}
\end{figure}

In order to achieve this without introducing many breaking changes for conflict analysis, we utilize \code{C++} exception to break from conflict analysis and raise the backtracking information expressed in a tuple of (destination level, propagating literal, reference to the reason clause), which will be retrieved and processed by the \code{catch} block in the solving loop, guiding further backtracking and propagation. The analysis context, which stores the currently explored literals, will also be cleared after catching the exception. With this trick, only 5 lines of code in \code{analyze} are changed, and 10 lines of code in the solving loop are added. The updated code is shown below:

\begin{lstlisting}
  try {
    analyze(conflict, learnt_clause, backtrack_level);
  } catch (std::tuple<int, Lit, CRef> t) {
    for (int i = 0; i < analyze_to_clear.size(); i++) {
      seen[var(analyze_to_clear[i])] = 0;
    }
    auto [level, lit, c] = t;
    cancelUntil(level);
    uncheckedEnqueue(lit, c);
    continue;
  }
\end{lstlisting}

\section{Extension of cvc5 for integrating MiniSatUP}

% overview
After implementing MiniSatUP, we integrated it with cvc5 based on the existing cvc5 integration with CaDiCaL, where the \code{UserPropagator} is fully implemented to handle the interaction between cvc5 theory solvers and the SAT solver via IPASIR-UP. We copied the existing SAT solver class that implements IPASIR-UP for CaDiCaL, identified all functions it references the CaDiCaL solver, including those functions that are not part of IPASIR-UP but specific to CaDiCaL, and adapted MiniSatUP further to support these functions for a seamless integration.

The architecture of cvc5 is shown in Figure~\ref{fig:cvc5}. It has an internal MiniSat tightly integrated as a CDCL SAT solver, and it also connects with CaDiCaL, which is referenced as an external package, via IPASIR-UP interface. MiniSatUP should be designed to reuse IPASIR-UP interface to connect with cvc5 alongside CaDiCaL.

\begin{figure}[!htbp]
  \centering
  \includesvg[width=0.5\textwidth]{cvc5.svg}
  \caption{Architecture of cvc5 with MiniSat and CaDiCaL}
  \label{fig:cvc5}
\end{figure}

% copy cadical.h
In cvc5, we copied the existing \code{cadical.h} and \code{cadical.cpp}, which contain the CaDiCaL solver wrapper and the implementation of IPASIR-UP \code{UserPropagator}, and created respectively \code{minisatup.h} and \code{minisatup.cpp} for the integration of MiniSatUP. The symbols, as well as trace and statistics labels are renamed to MiniSatUP to distinguish from CaDiCaL. We didn't try to connect to and reuse the existing code directly because the IPASIR-UP implementation in cvc5 is still tightly bound with CaDiCaL, with a lot of symbols named after CaDiCaL and a lot of CaDiCaL-specific procedures. An abstraction of the common interface for both CaDiCaL and MiniSatUP as well as other possible SAT solvers that implement IPASIR-UP is still needed to be designed and developed in cvc5.

% other interface functions
Now a direct compilation and linking is still not yet possible because of these CaDiCaL-specific functions which are not implemented by MiniSatUP. By searching in the source code for all referenced functions of CaDiCaL solver, a list of interfaces is created in a separate \code{minisatup.h} in MiniSatUP package and later implemented. They include:

\begin{itemize}
  \item IPASIR interfaces:
  \begin{itemize}
    \item \code{void add(int lit)}: Add a literal to the current clause, ending with 0. If the corresponding variable of the literal is not created yet, create the variable first.
    \item \code{void assume(int lit)}: Add a literal to the current assumption list.
    \item \code{int solve()}: Start solving. The assumptions will be cleared after solving. Return value 10, 20, 0 mean SAT, UNSAT and UNDEFINED respectively in accordance with IPASIR.
    \item \code{int val(int lit)}: Get the value of a literal from a SAT result. The return value is the literal if it's true, or the negation of the literal if it's false.
    \item \code{bool failed(int lit)}: Check if the literal as a part of the assumptions contributes to the final conflict clause of an UNSAT result.
  \end{itemize}
  \item IPASIR-UP interfaces:
  \begin{itemize}
    \item \code{void connect_user_propagator(UserPropagator* propagator)}: As explained before, the \code{UserPropagator} is added to and referenced by the solver. cvc5 already has a full implementation of \code{UserPropagator}.
    \item \code{void add_observed_var(int var)}: Set the variable as observed. We added another field \code{observed} in the \code{Solver} class as a bitmap for tracking if each variable is observed and filtering new assignments.
    \item \code{void remove_observed_var(int var)}: Stop observing the variable.
    \item \code{bool is_decision(int lit)}: Check if the literal is a decision literal. A decision literal has assignment level larger than 0 an no reason clause.
    \item \code{void phase(int lit)}: Set the phase of a variable. In MiniSat it is referred to as \code{polarity}.
  \end{itemize}
  \item CaDiCaL-specific interfaces:
  \begin{itemize}
    \item \code{int fixed(int var)}: Check if the variable has a fixed assignment. A variable with fixed assignment is assigned on level 0. In CaDiCaL, which supports out-of-order assignment, the variable could be assigned with actual level 0 but on a non-zero decision level. While in MiniSatUP, which hasn't yet supported out-of-order assignment, it is always assigned on decision level 0 after backtracking.
    \item \code{void connect_listener(FixedAssignmentListener* listener)}: Add a fixed-assignment listener. \code{FixedAssignmentListener} has one callback function \code{virtual void notify_fixed_assignment(int)}, where fixed assignments are notified eagerly, in addition to \code{notify_assignment} in IPASIR-UP interface. This is a synchronous version for the function \code{int fixed(int var)}. It is called along with \code{notify_assignment} in MiniSatUP if current decision level is 0.
    \item \code{void connect_learner(Learner* learner)}: Add a clause learner to the solver. A callback function \code{virtual void learn(int lit)} from the \code{Learner} class is for the solver to notify the user application about a learned clause generated from conflict analysis. The learned clause can be used to guide user applications, here in cvc5 the theory solvers, for further decision-makings. It is to be noted that in MiniSat, a learnt clause with low activities can be later removed, but there is no interface yet for notifying this removal, and the handling mechanism of learnt clauses in cvc5 is not clear and dependent on plugins, which might lead to inefficiency or unexpected behaviors.
    \item \code{void terminate()}: Terminate the solving process asynchronously. We set a flag in solver which the solver checks in every loop and exit if it is set.
    \item \code{void connect_terminator(Terminator* terminator)}: Connect the \code{Terminator} to the solver. The \code{Terminator} class contains only one callback function \code{virtual bool terminate()} that will be called synchronously by the solver to check if it needs to terminate. This provides another way of terminating in addition to \code{void terminate()}.
  \end{itemize}
\end{itemize}

We added declarations of these interface functions first without implementing them, just to make sure they can be linked correctly with cvc5. Then the functions are implemented only when errors occur, and are tested immediately after each implementation, so that only the necessary functions are included, and the behavioral change that each function introduces can be analyzed and understood. In the end, some functions are never called or referenced, including functions in IPASIR-UP like \code{disconnect_user_propagator} and \code{unphase}.

% linking minisatup in cvc5
The cvc5 project is built with CMake and its external dependencies are added through command \code{find_package} in CMake. We wrapped MiniSatUP in a CMake package for cvc5 to be able to reference and link with it. Corresponding CMake scripts are also added in cvc5 for automatically downloading and building MiniSatUP from its source. And option \code{--sat-solver=minisatup} is also supported, so that MiniSatUP can be selected by cvc5 along with its internal MiniSat and CaDiCaL for parallel experimenting and testing.
