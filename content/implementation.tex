\chapter{Implementation}

This chapter provides a detailed account of the implementation of MiniSatUP (MiniSat with IPASIR-UP) and the extension of cvc5 for integrating with MiniSatUP.

\section{Adaptation of MiniSat to IPASIR-UP}

% overview and principle
Adaptation of MiniSat to IPASIR-UP involves several steps. First, the IPASIR-UP interface is added to the header file and interaction with user propagator is inserted in the solving loop. Then, adding a clause provided by user propagator during solving is implemented. Finally, adding an externally propagated literal from user and lazy explaination of the literal is implemented.

MiniSat contains \code{core} solver and \code{simp} solver. In addition to the core CDCL solving loop performed by \code{core} solver, \code{simp} solver performs subsumption and variable elimation. In this work, only the \code{core} solver is modifed. And the modification is made as minimum as possible, without altering the major control flow of the original code, so that the solver's original behaviour could be preserved while cleanly supporting the IPASIR-UP interface, enabling an easier inspection and comparison of the behaviour change introduced by the modification. In total, around 400 lines of code are added including comments, and only around 10 lines of original code are changed.

% adding UserPropagator interface
Firstly, the \code{UserPropagator} class declaration of the IPASIR-UP interface is added in the header file \code{Solver.h}, and the \code{user_propagator} member variable is added to \code{MiniSat::Solver}, which can be set by \code{connect_user_propagator} for the solver to interact with during solving. If \code{user_propagator} is not initialized, then the \code{Solver} behaves just like the original solver.

% interaction within CDCL loop
%% assignment and backtrack notification
If \code{user_propagator} is initialized in \code{Solver}, it will interact with the solver in each CDCL loop after propagation and possible conflict analysis, before the next decision is made. At the beginning of each interaction, the user propagator is synchronized of the current assignments and possible backtracks. An index on the trail up to which the assignments are notified is maintained for this purpose. Then the user propagator is requested of possible external propagations and external clauses.

%% decision and check model
When there are no such upropagationsnits or clauses, or there's no consequent change of control flow after adding them, the user propagator is requested of the next decision literal, if there are still unassigned variables. The new decision is taken and notified to user propagator while going to the next loop of propagation. Or the user propagator is requested to do a full model check before returning SAT if every variable is assigned, so that a new solver call could be avoided if there should still be inconsistence of model on the user side. And when the model check fails, the loop is continued and user propagator is responsible to provide new propagations or clauses to be taken into account.

% external clause addition during solving
%% comparison with clause addition after solving
Secondly, adding a clause during solving is supported. Adding a clause during solving is more challenging than adding a clause after each solving loop. A normal incremental clause addition, as is required in IPASIR interface, only happens when the solving is finished. At this time a variable is either assigned at root-level or unassigned. The clause to be added can be directly simplified by removing false literals. And after simplification of the clause, there are only 4 cases:

\begin{itemize}
  \item The clause is skipped when it contains a true literal or is tautology.
  \item The result is set as UNSAT when the clause is empty.
  \item The unit is propagated when the clause contains only one literal.
  \item The clause is added to the clause set and watched by the first two literals.
\end{itemize}

But during solving, the literals in a clause can be assigned at different decision levels, and after addition of the clause, there might be multiple consequences that leads to different control flow changes in the current solving loop.

%% interface description
Method \code{bool add_clause_solving(vec<Lit>& clause, bool forgettable, CRef& conflict, bool& propagate)} is added in core \code{MiniSat::Solver}, dedicated to support clause addition during solving. This method handles all scenarios that might happen when a new clause is added during solving. These scenarios are:

\begin{itemize}
  \item The clause is skipped.
  \item The result is UNSAT.
  \item The clause is added, with the following possible consequences:
    \begin{itemize}
      \item No propagation or conflict analysis needed.
      \item Propagation needed.
      \item Conflict analysis needed.
    \end{itemize}
\end{itemize}

The input parameters \code {vec<Lit>& clause} and \code{bool forgettable} give the clause and tell whether it is forgettable. A forgettable clause is indicated by the user propagator when it provides a clause, and it can be removed during simplification of the clause set.

The returning \code{bool} indicates whether UNSAT is produced by this clause (returning true when UNSAT, otherwise false). If propagation is needed, the literal to propagate is assigned and added to trail, the output parameter \code{bool& propagate} is set true, and the program goes to the next loop for propagation. And when conflict analysis is needed, \code{CRef& conflict} ist set as the current added clause, and the program goes to conflict analysis. When no propagation or conflict analysis is needed, none of the output parameters will be set, and the control flow goes further to check model or the next decision.

The interaction with user propagator and adding an external clause is inserted into the original CDCL loop, as figure~\ref{fig:flow} shows.

\begin{figure}
  \centering
  \includesvg[width=\textwidth]{flow.drawio.svg}
  \caption{Original CDCL loop in MiniSat and updated CDCL loop}
  \label{fig:flow}
\end{figure}

%% invariant of 2-watching scheme
In order to make sure the new clause is added without breaking the existing 2-watching scheme, an invariant across decision levels is established as following:

\begin{itemize}
  \item In decision level \code{l > 0}:
  \begin{itemize}
    \item A propagating clause is watched by the propagated literal(assigned true) and another literal(assigned false), both assigned on level l.
    \item A conflict clause is watched by two literals(both false) on level l.
  \end{itemize}
  \item After backtracking to a lower level \code{k < l}:
  \begin{itemize}
    \item The propagating clause or conflict clause at level l is still watched by the same two literals, now both unassigned.
  \end{itemize}
\end{itemize}

%% implementation
The clause to be added is first sorted by its literals and their current levels in the following order, so that when the first two literals become watching literals of the current clause, the clause will be still watched correctly by the two literals after backtracking according to the invariant:

true literals (level low - high) - unassigned literals - false literals (level high - low)

Similar to clause addition after solving, the clause is also simplified by removing root-level false literals. And when the clause contains a root-level true literal, or it is a tautology, it is skipped and the funtion returns without any additional consequence, and the next clause is requested until there's no more external clauses by the user propagator.

When the clause contains only one literal, it is assigned true after backtracking to root level, and propagated. When the clause contains at least two literals, it is added to the clause set, and is watched by the first two literals after sorting. Depending on the assignment status of the 2 watching literals, there can be 6 cases, and their levels when being assigned can introduce more sub-cases. Each case leads to its own outcome:

\begin{itemize}
  \item \code{false, false}: All literals in this clause are falsified so the clause a conflict. We check the levels of the watching literals (respectively a, b):
  \begin{itemize}
    \item \code{a = b}: This clause is a real conflict. We backtrack to level a/b and do conflict analysis.
    \item \code{a > b}: This clause just needs propagation.
  \end{itemize}
  \item \code{unassigned, false}: Propagation.
  \item \code{unassigned, unassigned}: No further action.
  \item \code{true, false}: When level \code{a > b}, backtrack and propagation, otherwise no further action.
  \item \code{true, unassigned}: No further action.
  \item \code{true, true}: No further action.
\end{itemize}

When the clause causes a propagation, we always backtrack to the level of the second literal, and then assign the first literal on this level, so as to make sure the levels of assignment for the two watching literals are always the same.

\todo{nonchro, introduce out-of-order assignments and the bug with cadical}

% external propagation and lazy explaination
In the last step of adapting MiniSat to IPASIR-UP, external propagation and lazy explaination of the externally propagated literal is supported.

Usually when a literal is assigned, we need to provide its reason clause. And the reason clause is needed during conflict analysis. But considering that not all reason clauses will be explored, it could be more efficient that the reason is not provided to the solver immediately, but only when it is needed, to avoid uncessary storage space and cost of generating the reason clause on the user side.

In the case of external propagation, only the propagated literal is required from the user propagator. This literal will be assigned with a tag \code{CRef_External_False} or \code{CRef_External_True} declaring that its reason clause is not present yet. And since the reason clause is attached with the cooresponding variable of the literal only, the tag must also indicate whether the literal is falsified, so it can be computed correctly from the variable.

When the externally propagated literal from user propagator is already assigned true, we skip it. And when it's already assigned false, which means that there is a conflict, we get the reason clause immediately and add the clause by reusing our previous function \code{add_clause_solving} to avoid duplication.

Like a clause added during solving, a clause lazily added during conflict analysis is also sorted the same way and watched by the first two literals, and it can also cause propagation to be re-performed on a lower decision level. When the clause is a unit clause, a backtrack to root level is necessary. And when the watching literals of the clause are of different levels, it is also necessary to align their levels and redo the propagation. When such a backtrack is to be performed on addition of an incoming clause, the conflict analysis will be interrupted by a C++ exception, and the analysis context will be cleared.
\todo{what is the analysis cotext and how many lines changed here}

\section{Extension of cvc5 for integrating MiniSatUP}

% overview
After implementing MiniSatUP, we integrated it with cvc5 based on the existing cvc5 integration with CaDiCaL, where the full \code{UserPropagator} is implemented to handle the interaction between cvc5 theory solvers and the SAT solver via IPASIR-IP, and CaDiCaL is referenced as an external package. We copied the existing sat solver class that implements IPASIR-UP for CaDiCaL, identified all functions it references the CaDiCaL solver, including those functions that are not part of IPASIR-UP, and adapted MiniSatUP further to support these functions.

The architecture of cvc5 is shown in figure~\ref{fig:cvc5}, which has an internal MiniSat, and connects with CaDiCaL via IPASIR-UP interface.

\begin{figure}
  \centering
  \includesvg[width=0.5\textwidth]{cvc5.drawio.svg}
  \caption{Architecture of cvc5 with MiniSat and IPASIR-UP interface}
  \label{fig:cvc5}
\end{figure}

\todo{why copying the code, not reusing the common code for both CaDiCaL and MiniSatUP?}

% copy cadical.h
In cvc5, we copied the existing \code{cadical.h} and \code{cadical.cpp}, which contain the implementation of IPASIR-UP, and created \code{minisatup.h} and \code{minisatup.cpp} for the integration. The symbols are renamed to \code{MiniSatUP} to distinguish from CaDiCaL.

% other interface functions
But a direct compilation and linking is not yet possible, because in this implementation of cvc5 integration of CaDiCaL, there are functions referenced from CaDiCaL solver that are not implemented by MiniSatUP. By a simple search in the code of all referenced functions, a list is created in minisatup.h, and these functions are later implemented in MiniSatUP as well. They include:

\begin{itemize}
  \item IPASIR interface functions.
  \begin{itemize}
    \item \code{void add(int lit)}: Add a literal to the current clause, with ending 0. If the corresponding variable is not created yet, create the variable first.
    \item \code{void assume(int lit)}: Add a literal to the current assumption.
    \item \code{int solve()}: Start solving. The assumptions will be cleared after solving. Return value 10, 20, 0 mean SAT, UNSAT and UNDEF respectively in accordance with CaDiCaL.
    \item \code{int val(int lit)}: Get the value of a literal from a SAT result. The return value is the literal if it's true, and the negation of the literal if it's false.
    \item \code{bool failed(int lit)}: Check if the literal is a part of the assumptions that appeared in the final conflict clause for an UNSAT result.
  \end{itemize}
  \item IPASIR-UP interface functions.
  \begin{itemize}
    \item \code{void connect_user_propagator(UserPropagator *user_propagator)}: The \code{UserPropagator} is fully implemented by cvc5 and will be called by solver.
    \item \code{void add_observed_var(int var)}: This method is only implemented this way, to ensure the variable is constructed. No additional data structure is added in MiniSatUP to support observed variables, as in cvc5 all variables are observed. So all assignments will be notified. And in cvc5 the assignments of inactive variables will be filtered out.
    \item \code{void remove_observed_var(int var)}:
    \item \code{bool is_decision(int lit)}: Check if the literal is a decision literal, whose assignment level is larger than 0 and has no reason clause.
    \item \code{void phase(int lit)}: Set the phase, or polarity of a variable.
  \end{itemize}
  \item CaDiCaL-specific functions.
  \begin{itemize}
    \item \code{int fixed(int var)}: Check if the variable has a fixed assignment, which means it is assigned on level 0.
    \item \code{void terminate()}: Terminate the solving process asynchronously. This sets a flag in solver and the solver checks the flag in every loop if there is a need to exit.
    \item \code{void connect_terminator(Terminator *terminator)}: The \code{Terminator} class contains only one callback function \code{virtual bool terminate()} that will be called synchronously by the solver to check if the solving process needs to terminate. This provides another way of terminating in addition to \code{void terminate()} which works asynchronously.
    \item \code{void connect_learner(Learner *learner)}: The \code{Learner} class contains a callback function \code{virtual void learn(int lit)} to notify the user about a learned clause after conflict analysis. The learned clause can be processed by the theory solvers to extract information that might help with solving.
    \item \code{void connect_fixed_assignment_listener(FixedAssignmentListener *listener)}: The \code{FixedAssignmentListener} has one callback function \code{virtual void notify_fixed_assignment(int)}, where literals with fixed assignments are notified alone, in addition to \code{notify_assignment} in IPASIR-UP interface. This can be benificial with CaDiCaL which implements chronological backtracking, where the fixed assignments can be kept even after backtracking without having to renotify them again. In MiniSatUP this is not implemented as chronological backtracking is not supported yet.
  \end{itemize}
\end{itemize}

During the process of implementing these additional interface functions, they are tested at the same time, first only with declaration without implementation, just to make sure they can be linked correctly. Then the functions are implemented only when errors occur, so that only the necessary functions are included, and the bahavioral change each function introduces can be analyzed. In the end, some functions are not implemented since they never get called or referenced, including some IPASIR-UP functions. And there are functions that are specific to CaDiCaL but still referenced in cvc5, which can potentially be included in the IPASIR-UP interface as well.

% linking minisatup in cvc5
cvc5 is built with CMake and its dependencies are added through \code{find_package} command in CMake. We wrapped MiniSatUP in a CMake package for cvc5 to be able to reference and link with it. And we also added the option \code{--sat-solver=minisatup}, so that MiniSatUP can be selected by cvc5 along with its internal MiniSat and CaDiCaL.
