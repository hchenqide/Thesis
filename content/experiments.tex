\chapter{Experiments}

This chapter presents the experiments conducted on MiniSatUP and its integration with cvc5. We performed correctness testing by a fuzzer implemented for IPASIR-UP as well as cvc5 regression tests and fixed bugs during development, and we also conducted performance testing on cvc5 after the intergration, which demonstrates no measurable performance overhead with introducing IPASIR-UP.

\section{Correctness}

% overview
In developing a program for tasks like formal verification of hardware and software, its own correctness and robustness is essential. Testing techniques like assertions, fuzzing and regression tests are employed in the development of many such software. In the testing for MiniSatUP and cvc5 we also used such techniques.

% fuzzing
Fuzzing is an automated testing technique that generates a large number of random and potentially adversarial input data to uncover bugs, crashes, or unexpected behavior in software. In this work, a fuzzer for the IPASIR-UP interface is developed during implementation of MiniSatUP before its integration in cvc5, to ensure a full achievement to the functionality of the interface as well as its correctness.

% minisat fuzzer
%% connection
The fuzzer takes a CNF file as input, which can be generated by CNFuzz \cite{BrummayerLonsingBiere-SAT10} with a random seed, and splits the clauses into two parts, with the first part given to the solver initially, and the rest added via IPASIR-UP interface. A \code{UserPropagator} implementing IPASIR-UP interfaces will be given to the solver via \code{connect_user_propagator} for it to interact with.

%% external clause
Adding an external clause is first implemented by the fuzzer. On each interaction, if there is a next external clause available and with a certain probability, the clause will be provided. We also inserted statistics and assertions on each case when adding an external clause, to ensures all cases when adding an external clauses is hit and tested, and to inspect any possible error. An example statistics table counting how many times each case is hit with a random input is shown below:

\todo{table}

\code{cb_check_found_model} is also implemented by checking if there are still clauses left to be added, and if all clauses are satisfied by current assignments.

%% early bugs
At this stage, a wrong assertion to a case of possible states for the 2-watching literals is discovered and fixed. And a bug in clause sorting predicate which leads to undesired order of the two watching literals is also found by an assertion error during fuzzing. Another issue related with the timing of connecting user propagator to the solver is discovered and fixed, where the clauses are added to the solver before connecting to user propagator and therefore some instant assignments from unit clauses are not informed to the user propagator leading to incorrect model. Batch notification of assignments is later implemented and more assertions on connecting user propagators are added.

%% external propagation and lazy propagation
Next, the lazy propagation interface is implemented. The \code{UserPropagator} checks if the next clause to be added actually leads to propagation based on the current notified assignments. When the clause only contains false literals but one unassigned literal, the implied literal is returned to the sat solver for propagation, while the clause is saved in a map indexed by the propagated literal and can be retrieved from the literal during lazy explaination. Other clauses are still added normally though the \code{cb_has_external_clause} and \code{cb_add_external_clause_lit} callbacks. When a backtrack happens, the entries in the map whose literals are unassigned will be removed from the map.

% cvc5 make check and bugs after cvc5 integration
This fuzzer has helped discovering bugs in MiniSatUP especially for adding external clauses and external propagations interfaces. But it doesn't cover the interfaces like decisions and assumptions, as implementing such interfaces are not straightforward without an actual user application. After integrated with cvc5, these interfaces are fully tested with a few more bugs discovered and fixed.

With thousands of the regression test cases from cvc5, which are still evolving along with the development, we are able to test cvc5 by running the \code{make check} command after building cvc5 integrated with MiniSatUP. And several more bugs from MiniSatUP has been discovered. Also a bug within cvc5 and a bug in CaDiCaL are discovered and fixed from comparison of test results.

Before integration with cvc5, the compiler flag \code{-fsanitize=address} has also been enabled in MiniSatUP to prevent possible memory leaks, and during fuzzing and testing no memory leak has happened. This flag is removed during integration because it's not compatible with current cvc5 builds, and removing this flag causes a bug in the fuzzer to appear, where during external propagation \code{clauses.front()} is called without first checking if \code{clauses} is empty.

\todo{the cvc5 bug and the cadical bug}

In a final running of \code{make check} of cvc5, an unfinished case is identified to be due to the missing implementation of \code{Terminator} from CaDiCaL interface, thus exhibiting different behavior as with CaDiCaL. But so far, the \code{make check} command still woundn't pass completely due to several unfinished cases that eventually timeout. These cases still need to be examined.

% bug classificaiton by severity, difficulty to find/fix
All bugs are listed in the table below as summarized:

\todo{table of all bugs}

\section{Performance}

% benchmarks

We performed performance test on cvc5 with the dataset.

% result and comparison with cadical/minisat

no discrepancy occurred
